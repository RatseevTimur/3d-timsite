import * as THREE from 'three'
import { useEffect, useRef, useState, Suspense } from 'react'
import './App.css'
import {
  Environment, OrbitControls, PresentationControls, useGLTF, Html,
  ContactShadows
} from '@react-three/drei'
import { useFrame, Canvas, useThree } from '@react-three/fiber'
import { useSpring } from '@react-spring/core'
import { a as three } from '@react-spring/three'
import { a as web } from '@react-spring/web'

import Laptop from './Laptop.jsx'
import Iphon from './Iphon.jsx'
import Desk from './Desk'
// import HeroPage from './HeroPage.jsx'
function Box(props) {
  const ref = useRef()
  const [hovered, hover] = useState(false)
  return (
    <mesh {...props} castShadow ref={ref} onPointerOver={(event) => hover(true)} onPointerOut={(event) => hover(false)}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} />
    </mesh>
  )
}

function Shadows(props) {
  const { viewport } = useThree()
  return (
    <mesh receiveShadow scale={[viewport.width, viewport.height, 1]} {...props}>
      <planeGeometry />
      <shadowMaterial transparent opacity={0.5} />
    </mesh>
  )
}

// function Model({open, hinge, ...props}) {
//   const group = useRef()
//   // Load model
//   const { nodes, materials } = useGLTF('src/models/mac-draco.glb')
//   // Take care of cursor state on hover
//   const [hovered, setHovered] = useState(false)
//   useEffect(() => void (document.body.style.cursor = hovered ? 'pointer' : 'auto'), [hovered])
//   // Make it float
//   // useFrame((state) => {
//   //   const t = state.clock.getElapsedTime()
//   //   group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, Math.cos(t / 2) / 20 + 0.25, 0.1)
//   //   group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, Math.sin(t / 4) / 20, 0.1)
//   //   group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, Math.sin(t / 8) / 20, 0.1)
//   //   group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, (-2 + Math.sin(t / 2)) / 2, 0.1)
//   // })
//   useFrame((state) => {
//     const t = state.clock.getElapsedTime()
//     group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, open ? Math.cos(t / 10) / 10 + 0.25 : 0, 0.1)
//     group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, open ? Math.sin(t / 10) / 4 : 0, 0.1)
//     group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, open ? Math.sin(t / 10) / 10 : 0, 0.1)
//     group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, open ? (-2 + Math.sin(t)) / 3 : -4.3, 0.1)
//   })
//   // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
//   return (
//     <group ref={group} {...props} onPointerOver={(e) => (e.stopPropagation(), setHovered(true))} onPointerOut={(e) => setHovered(false)} dispose={null}>
//       <group /*rotation-x={-0.425}*/rotation-x={hinge} position={[0, -0.04, 0.41]}>
//         <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
//           <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
//           <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry} />
//           <mesh material={materials['screen.001']} geometry={nodes['Cube008_2'].geometry}>
//             {/* Drei's HTML component can "hide behind" canvas geometry */}
//             {/* <Html className="content" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform occlude>
//               <div className="wrapper" onPointerDown={(e) => e.stopPropagation()}>
//                 <HeroPage />
//               </div>
//             </Html> */}
//           </mesh>
//         </group>
//       </group>
//       <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
//       <group position={[0, -0.1, 3.39]}>
//         <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
//         <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
//       </group>
//       <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
//     </group>
//   )
// }

function Model({ open, hinge, ...props }) {
  const group = useRef()
  // Load model
  const { nodes, materials } = useGLTF('src/models/mac-draco.glb')
  // Take care of cursor state on hover
  const [hovered, setHovered] = useState(false)
  useEffect(() => void (document.body.style.cursor = hovered ? 'pointer' : 'auto'), [hovered])
  // Make it float in the air when it's opened
  useFrame((state) => {
    const t = state.clock.getElapsedTime()
    group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, open ? Math.cos(t / 10) / 10 + 0.25 : 0, 0.1)
    group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, open ? Math.sin(t / 10) / 4 : 0, 0.1)
    group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, open ? Math.sin(t / 10) / 10 : 0, 0.1)
    group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, open ? (-2 + Math.sin(t)) / 3 : -4.3, 0.1)
  })
  // The view was auto-generated by: https://github.com/pmndrs/gltfjsx
  // Events and spring animations were added afterwards
  useEffect(()=>{
    const h1Element = document.querySelector('h1');

    window.addEventListener('scroll', () => {
      const scrollTop = window.scrollY;
      const offset = scrollTop / 2; // Adjust the offset value to control the movement speed
      h1Element.style.top = `calc(50% - ${offset}px)`;
    });

    // return(
    //   window.removeEventListener('scroll')
    // )
  },[])
  return (
    <group ref={group} {...props} onPointerOver={(e) => (e.stopPropagation(), setHovered(true))} onPointerOut={(e) => setHovered(false)} dispose={null}>
      <three.group rotation-x={hinge} position={[0, -0.04, 0.41]}>
        <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
          <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
          <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry} />
          <mesh material={materials['screen.001']} geometry={nodes['Cube008_2'].geometry}>
            {/* Drei's HTML component can "hide behind" canvas geometry */}
            <Html className="content" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform occlude
            // distanceFactor={1.16}
            >
              <div className="wrapper" onPointerDown={(e) => e.stopPropagation()}>
                {/* <HeroPage /> */}
                <iframe src="https://timur-site.netlify.app" height={800} width={1200}/>
              </div>
            </Html>
          </mesh>
        </group>
      </three.group>
      <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
      <group position={[0, -0.1, 3.39]}>
        <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
        <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
      </group>
      <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
    </group>
  )
}

function App() {
  // This reference gives us direct access to the THREE.Mesh object
  const ref = useRef(null)
  // This flag controls open state, alternates between true & false
  const [open, setOpen] = useState(false)
  // We turn this into a spring animation that interpolates between 0 and 1
  const props = useSpring({ open: Number(open) })

  // // Hold state for hovered and clicked events
  // const [hovered, hover] = useState(false)
  // const [clicked, click] = useState(false)
  // const [clickedIphon, clickIphon] = useState(false)

  // useEffect(()=>{
  //   if(clicked){
  //     ref.current.rotation.y = .1
  //     ref.current.rotation.x = .1
  //   }
  // },[clicked])

  // useEffect(() => {
  //   document.body.style.cursor = hovered ? 'pointer' : 'auto'
  // }, [hovered])

  // Subscribe this component to the render-loop, rotate the mesh every frame
  // useFrame((state, delta) => (ref.current.rotation.y += delta/10))
  // useFrame((state, delta) => {
  //   if(ref.current != null){
  //     if(clicked){
  //       // if(ref.current.rotation.y > -.5) { ref.current.rotation.y -= delta }
  //       // if(ref.current.rotation.x < .13) { ref.current.rotation.x += delta }

  //       // if( ref.current.position.y < .6) { ref.current.position.y += delta }
  //       // if(ref.current.position.x > -6.2) { ref.current.position.x -= delta }
  //       // if(ref.current.position.z < 7) { ref.current.position.z += delta }
  //       ref.current.rotation.y = -.5
  //       ref.current.rotation.x = .13

  //       ref.current.position.y = -0.3
  //       ref.current.position.x = -4.2
  //       ref.current.position.z = 4
  //     }else{
  //       ref.current.rotation.y = -.5
  //       ref.current.rotation.x = 0

  //       ref.current.position.y = 0
  //       ref.current.position.x = 0
  //       ref.current.position.z = 0
  //     }
  //   }
  // })

  const canvasRef = useRef(null);

  useEffect(() => {
    const handleScroll = () => {
      console.log("!!", canvasRef.current.scrollTop);
    };
    canvasRef.current.addEventListener('scroll', handleScroll);
    return () => {
      canvasRef.current.removeEventListener('scroll', handleScroll);
    };
  }, []);


  // Return the view, these are regular Threejs elements expressed in JSX
  return (
    <div ref={canvasRef} style={{ overflow: "scroll", height: "100vh" }}>
      {/* <Canvas camera={{ position: [-5, 0, -15], fov: 55 }}>
        <pointLight position={[10, 10, 10]} intensity={1.5} />
        <Suspense fallback={null}>
          <group rotation={[0, Math.PI, 0]} position={[0, 1, 0]} onClick={(e) => (e.stopPropagation(), setOpen(!open))}>
            <Model open={open} hinge={props.open.to([0, 1], [1.575, -0.425])}/>
          </group>
          <Environment preset="city" />
        </Suspense>
        <ContactShadows position={[0, -4.5, 0]} scale={20} blur={2} far={4.5} />
        <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 2.2} maxPolarAngle={Math.PI / 2.2} />
      </Canvas> */}
      <web.main style={{ 
        // background: props.open.to([0, 1], ['#f0f0f0', '#d25578']) 
        // background: props.open.to([0, 1], [
        //   `radial-gradient(farthest-corner at 50% 50%, #f0f0f0, #f0f0f0)`,
        //   `radial-gradient(farthest-corner at 50% 50%, #d25578, #f0f0f0)`
        // ])
        background: props.open.to([0, 1], [
          `radial-gradient(closest-side at 50% 50%, #f0f0f0, #f0f0f0)`,
          `radial-gradient(closest-side at 50% 50%, #d25578, #f0f0f0)`
        ])
        // background: props.open.to([0, 1], [
        //   `radial-gradient(closest-corner at 50% 50%, #f0f0f0, #f0f0f0)`,
        //   `radial-gradient(closest-corner at 50% 50%, #d25578, #f0f0f0)`
        // ])
        
      
        }}>
        <web.h1 style={{ opacity: props.open.to([0, 1], [1, 0]), transform: props.open.to((o) => `translate3d(-50%,${o * 50 - 100}px,0)`) }}>click</web.h1>
        <Canvas dpr={[1, 2]} camera={{ position: [0, 0, -30], fov: 35 }}>
          <three.pointLight position={[10, 10, 10]} intensity={1.5} color={props.open.to([0, 1], ['#f0f0f0', '#d25578'])} />
          <Suspense fallback={null}>
            <group rotation={[0, Math.PI, 0]} onClick={(e) => (e.stopPropagation(), setOpen(!open))}>
              <Model open={open} hinge={props.open.to([0, 1], [1.575, -0.425])} />
            </group>
            <Environment preset="city" />
          </Suspense>
          <ContactShadows position={[0, -4.5, 0]} opacity={0.4} scale={20} blur={1.75} far={4.5} />
          <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 2.2} maxPolarAngle={Math.PI / 2.2} />
        </Canvas>
      </web.main>
      <div ref={ref} className="container">
        <div className="text">
          Попробуй нажать на ноутбук. Еще этот текст можно копировть, и на нем прям 3D объекты и кстати если хотите вернуться обратно нажмите на один из них.
        </div>
        <Canvas
          shadows
          frameloop="demand"
          camera={{ position: [0, 0, 4] }}
          style={{ pointerEvents: 'none' }}
          // In order for two dom nodes to be able to receive events they must share
          // the same source. By re-connecting the canvas to a parent that contains the
          // text content as well as the canvas we do just that.
          eventSource={ref}
          eventPrefix="offset">
          <ambientLight intensity={0.5} />
          <directionalLight position={[10, 10, 10]} angle={0.15} penumbra={1} castShadow shadow-mapSize={[2024, 2024]} />
          <pointLight position={[10, 0, 0]} />
          <Box position={[-1.2, 0, 0]} />
          <Box position={[1.2, 0, 0]} />
          <Shadows position={[0, 0, -0.5]} />
        </Canvas>
      </div>
    </div>
  )
}

export default App

// "Попробуй нажать на ноутбук. Еще этот текст можно копировть, и на нем прям 3D объекты и кстати если хотите вернуться обратно нажмите на один из них."

// Этот текст будет появляться на странице нужно определять какой у пользователя выбран язык и исходя из этого выбирать эту надпись на его языке
// Переведи ее на Английский, немецкий, Венгерский, Японский, Китайский и Арабский и напиши код определяющий язык поьзователя на JS

// const userLanguage = navigator.language || navigator.languages[0];
// console.log(userLanguage); // Output: "en-US" or "de-DE" or "hu-HU" etc.


// import i18next from 'i18next';

// const translations = {
//   en: {
//     text: "Try clicking on the laptop. You can also copy this text and directly interact with 3D objects. By the way, if you want to go back, click on one of them."
//   },
//   ru: {
//     text: "Попробуй нажать на ноутбук. Еще этот текст можно копировть, и на нем прям 3D объекты и кстати если хотите вернуться обратно нажмите на один из них."
//   },
//   de: {
//     text: "Probieren Sie, auf den Laptop zu klicken. Sie können auch diesen Text kopieren und direkt mit 3D-Objekten interagieren. Übrigens, wenn Sie zurückkehren möchten, klicken Sie auf einen von ihnen."
//   },
//   hu: {
//     text: "Próbálja meg kattintani a laptopra. Másolhatja is ezt a szöveget, és közvetlenül interakcióba léphet a 3D objektumokkal. És ha vissza szeretne térni, kattintson egyikükre."
//   },
//   ja: {
//     text: "ラップトップをクリックしてみてください。このテキストをコピーして、3D オブジェクトと直接インタラクションすることもできます。また、戻りたい場合は、ひとつをクリックしてください。"
//   },
//   zh: {
//     text: "尝试点击笔记本电脑。你也可以复制这个文本，并直接与 3D 对象交互。另外，如果你想返回，请点击其中一个。"
//   },
//   ar: {
//     text: "جرب النقر على لابتوب. يمكنك أيضا نسخ هذا النص و التفاعل مباشرة مع الكائنات ثلاثية الأبعاد. وعلاوة على ذلك، إذا كنت ترغب في العودة، انقر على واحد منهم."
//   }
// };

// i18next.init({
//   lng: userLanguage,
//   resources: translations
// });

// const translatedText = i18next.t('text');
// console.log(translatedText); // Output: Translated text based on user language