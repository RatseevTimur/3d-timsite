import * as THREE from 'three'
import { useEffect, useRef, useState, Suspense, useLayoutEffect } from 'react'
import './App.css'
import {
  Environment, OrbitControls, PresentationControls, useGLTF, Html,
  ContactShadows
} from '@react-three/drei'
import { useFrame, Canvas, useThree } from '@react-three/fiber'
import { useSpring } from '@react-spring/core'
import { a as three } from '@react-spring/three'
import { a as web } from '@react-spring/web'

function Box(props) {
  const ref = useRef()
  const [hovered, hover] = useState(false)
  return (
    <mesh {...props} castShadow ref={ref} onPointerOver={(event) => hover(true)} onPointerOut={(event) => hover(false)}>
      <boxGeometry args={[1, 3, 0.3]} />
      <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} />
    </mesh>
  )
}

function Shadows(props) {
  const { viewport } = useThree()
  return (
    <mesh receiveShadow scale={[viewport.width, viewport.height, 1]} {...props}>
      <planeGeometry />
      <shadowMaterial transparent opacity={0.5} />
    </mesh>
  )
}


function Model({ open, hinge, ...props }) {
  const group = useRef()
  // Load model
  const url = new URL('./assets/mac-draco.glb', import.meta.url);

  const { nodes, materials } = useGLTF(url.href)
  // Take care of cursor state on hover
  const [hovered, setHovered] = useState(false)
  useEffect(() => void (document.body.style.cursor = hovered ? 'pointer' : 'auto'), [hovered])
  // Make it float in the air when it's opened
  useFrame((state) => {
    const t = state.clock.getElapsedTime()
    group.current.rotation.x = THREE.MathUtils.lerp(group.current.rotation.x, open ? Math.cos(t / 10) / 10 + 0.25 : 0, 0.1)
    group.current.rotation.y = THREE.MathUtils.lerp(group.current.rotation.y, open ? Math.sin(t / 10) / 4 : 0, 0.1)
    group.current.rotation.z = THREE.MathUtils.lerp(group.current.rotation.z, open ? Math.sin(t / 10) / 10 : 0, 0.1)
    group.current.position.y = THREE.MathUtils.lerp(group.current.position.y, open ? (-2 + Math.sin(t)) / 3 : -4.3, 0.1)
  })
  // The view was auto-generated by: https://github.com/pmndrs/gltfjsx
  // Events and spring animations were added afterwards
  return (
    <group ref={group} {...props} onPointerOver={(e) => (e.stopPropagation(), setHovered(true))} onPointerOut={(e) => setHovered(false)} dispose={null}>
      <three.group rotation-x={hinge} position={[0, -0.04, 0.41]}>
        <group position={[0, 2.96, -0.13]} rotation={[Math.PI / 2, 0, 0]}>
          <mesh material={materials.aluminium} geometry={nodes['Cube008'].geometry} />
          <mesh material={materials['matte.001']} geometry={nodes['Cube008_1'].geometry} />
          <mesh material={materials['screen.001']} geometry={nodes['Cube008_2'].geometry}>
            {/* Drei's HTML component can "hide behind" canvas geometry */}
            <Html className="content" rotation-x={-Math.PI / 2} position={[0, 0.05, -0.09]} transform occlude
            // distanceFactor={1.16}
            >
              <div className="wrapper" onPointerDown={(e) => e.stopPropagation()}>
                {/* <HeroPage /> */}
                <iframe src="https://timur-site.netlify.app" height={780} width={1200} />
              </div>
            </Html>
          </mesh>
        </group>
      </three.group>
      <mesh material={materials.keys} geometry={nodes.keyboard.geometry} position={[1.79, 0, 3.45]} />
      <group position={[0, -0.1, 3.39]}>
        <mesh material={materials.aluminium} geometry={nodes['Cube002'].geometry} />
        <mesh material={materials.trackpad} geometry={nodes['Cube002_1'].geometry} />
      </group>
      <mesh material={materials.touchbar} geometry={nodes.touchbar.geometry} position={[0, -0.03, 1.2]} />
    </group>
  )
}

const Header = ({scrollTop, props}) => {
  return (
    <web.h1 style={{
      font: 'revert',
      opacity: props.open.to([0, 1], [1, 0]), transform: props.open.to((o) => `translate3d(-50%,${o * 50 - 100}px,0)`),
      visibility: scrollTop < 300 ? "visible" : "hidden"
    }}>
      click
    </web.h1>
  )
}

const translations = {
  en: {
    text: "Try clicking on the laptop. You can also copy this text and directly interact with 3D objects. By the way, if you want to go back, click on one of them. But only after you select all this text!"
  },
  ru: {
    text: "Попробуй нажать на ноутбук. Еще этот текст можно копировть, и на нем прям 3D объекты и кстати если хотите вернуться обратно нажмите на один из них. Но только после того как выделишь весь этот текст!"
  },
  de: {
    text: "Probieren Sie, auf den Laptop zu klicken. Sie können auch diesen Text kopieren und direkt mit 3D-Objekten interagieren. Übrigens, wenn Sie zurückkehren möchten, klicken Sie auf einen von ihnen. Aber nur nachdem Sie den ganzen Text ausgewählt haben!"
  },
  hu: {
    text: "Próbálja meg kattintani a laptopra. Másolhatja is ezt a szöveget, és közvetlenül interakcióba léphet a 3D objektumokkal. És ha vissza szeretne térni, kattintson egyikükre. De csak akkor, ha kiválasztja az egész szöveget!"
  },
  ja: {
    text: "ラップトップをクリックしてみてください。このテキストをコピーして、3D オブジェクトと直接インタラクションすることもできます。また、戻りたい場合は、ひとつをクリックしてください。但し、すべてのテキストを選択してください。"
  },
  zh: {
    text: "尝试点击笔记本电脑。你也可以复制这个文本，并直接与 3D 对象交互。另外，如果你想返回，请点击其中一个。但是，只有在你选择所有文本后。"
  },
  ar: {
    text: "جرب النقر على لابتوب. يمكنك أيضا نسخ هذا النص و التفاعل مباشرة مع الكائنات ثلاثية الأبعاد. وعلاوة على ذلك، إذا كنت ترغب في العودة، انقر على واحد منهم. ولكن فقط بعد أن تختار كل النص!"
  }
};

function App() {
  // This reference gives us direct access to the THREE.Mesh object
  const ref = useRef(null)
  // This flag controls open state, alternates between true & false
  const [open, setOpen] = useState(false)
  // We turn this into a spring animation that interpolates between 0 and 1
  const props = useSpring({ open: Number(open) })

  //scroll
  const canvasRef = useRef(null);
  const [scroll, setScroll] = useState(0)
  useEffect(() => {
    const handleScroll = () => {
      setScroll(canvasRef.current.scrollTop);
    };
    canvasRef.current.addEventListener('scroll', handleScroll);
    return () => {
      canvasRef.current.removeEventListener('scroll', handleScroll);
    };
  }, []);

  //Language
  const [userLanguage, setUserLanguage] = useState('');
  const [selectedTranslation, setSelectedTranslation] = useState('');
  useLayoutEffect(() => {
    const userLanguage = navigator.language || navigator.languages[0];
    setUserLanguage(userLanguage);
    // console.log(`User language: ${userLanguage}`);
    // Select the corresponding translation
    const selectedTranslation = translations[userLanguage.split('-')[0]] || translations.en;
    setSelectedTranslation(selectedTranslation.text);
  }, [userLanguage]);
  

  //TEXT SELECT
  const [selection, setSelection] = useState('');
  const [textInsideDiv, setTextInsideDiv] = useState('');

  useEffect(() => {
    const divElement = document.querySelector('.text');
    setTextInsideDiv(divElement.textContent);
  }, []);

  const handleButtonClick = () => {
    const selection = window.getSelection();
    setSelection(selection.toString());
    if (selection.toString() === textInsideDiv) {
      window.open("https://timur-site.netlify.app/")
    } else {
      alert('Not entire text is selected');
    }
  };

  // Return the view, these are regular Threejs elements expressed in JSX
  return (
    <div ref={canvasRef} style={{ overflow: "scroll", height: "100vh" }}>
      <web.main style={{
        // background: props.open.to([0, 1], ['#f0f0f0', '#d25578']) 
        background: props.open.to([0, 1], [
          `radial-gradient(closest-side at 50% 50%, #f0f0f0, #f0f0f0)`,
          `radial-gradient(closest-side at 50% 50%, #d25578, #f0f0f0)`
        ])
      }}>
        
        <Header scrollTop={scroll} props={props} />
        
        <Canvas dpr={[1, 2]} camera={{ position: [0, 0, -30], fov: 35 }}>
          <three.pointLight position={[10, 10, 10]} intensity={1.5} color={props.open.to([0, 1], ['#f0f0f0', '#d25578'])} />
          <Suspense fallback={null}>
            <group rotation={[0, Math.PI, 0]} onClick={(e) => (e.stopPropagation(), setOpen(!open))}>
              <Model open={open} hinge={props.open.to([0, 1], [1.575, -0.425])} />
            </group>
            <Environment preset="city" />
          </Suspense>
          <ContactShadows position={[0, -4.5, 0]} opacity={0.4} scale={20} blur={1.75} far={4.5} />
          <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 2.2} maxPolarAngle={Math.PI / 2.2} />
        </Canvas>
      </web.main>
      <div ref={ref} className="container">
        <div className="text">
          {selectedTranslation}
        </div>
        <Canvas
          shadows
          frameloop="demand"
          camera={{ position: [0, 0, 4] }}
          style={{ pointerEvents: 'none' }}
          // In order for two dom nodes to be able to receive events they must share
          // the same source. By re-connecting the canvas to a parent that contains the
          // text content as well as the canvas we do just that.
          eventSource={ref}
          eventPrefix="offset">
          <ambientLight intensity={0.5} />
          <directionalLight position={[10, 10, 10]} angle={0.15} penumbra={1} castShadow shadow-mapSize={[2024, 2024]} />
          <pointLight position={[10, 0, 0]} />
          <Box position={[-1.2, 0, 0]} rotation={[0,0,.2]} onClick={handleButtonClick}/>
          <Box position={[1.2, 1, 0]} rotation={[0,0, -.05]} onClick={handleButtonClick}/>
          <Shadows position={[0, 0, -0.1]} />
        </Canvas>
      </div>
    </div>
  )
}

export default App

// import i18next from 'i18next';

// const translations = {
//   en: {
//     text: "Try clicking on the laptop. You can also copy this text and directly interact with 3D objects. By the way, if you want to go back, click on one of them."
//   },
//   ru: {
//     text: "Попробуй нажать на ноутбук. Еще этот текст можно копировть, и на нем прям 3D объекты и кстати если хотите вернуться обратно нажмите на один из них."
//   },
//   de: {
//     text: "Probieren Sie, auf den Laptop zu klicken. Sie können auch diesen Text kopieren und direkt mit 3D-Objekten interagieren. Übrigens, wenn Sie zurückkehren möchten, klicken Sie auf einen von ihnen."
//   },
//   hu: {
//     text: "Próbálja meg kattintani a laptopra. Másolhatja is ezt a szöveget, és közvetlenül interakcióba léphet a 3D objektumokkal. És ha vissza szeretne térni, kattintson egyikükre."
//   },
//   ja: {
//     text: "ラップトップをクリックしてみてください。このテキストをコピーして、3D オブジェクトと直接インタラクションすることもできます。また、戻りたい場合は、ひとつをクリックしてください。"
//   },
//   zh: {
//     text: "尝试点击笔记本电脑。你也可以复制这个文本，并直接与 3D 对象交互。另外，如果你想返回，请点击其中一个。"
//   },
//   ar: {
//     text: "جرب النقر على لابتوب. يمكنك أيضا نسخ هذا النص و التفاعل مباشرة مع الكائنات ثلاثية الأبعاد. وعلاوة على ذلك، إذا كنت ترغب في العودة، انقر على واحد منهم."
//   }
// };

// i18next.init({
//   lng: userLanguage,
//   resources: translations
// });

// const translatedText = i18next.t('text');
// console.log(translatedText); // Output: Translated text based on user language